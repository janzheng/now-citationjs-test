"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.parse = exports.parseProp = parseProp;
exports.parseType = parseType;
exports.getLabel = getLabel;

var _core = require("@citation-js/core");

var _name = require("@citation-js/name");

var _date = require("@citation-js/date");

var _config = _interopRequireDefault(require("./config"));

var _types = _interopRequireDefault(require("./types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const getSeriesOrdinal = ({
  P1545
}) => P1545 ? parseInt(P1545[0]) : -1;

const getStatedAs = qualifiers => [].concat(...[qualifiers.P1932, qualifiers.P1810].filter(Boolean));

const parseName = ({
  value,
  qualifiers
}) => {
  let _getStatedAs = getStatedAs(qualifiers),
      _getStatedAs2 = _slicedToArray(_getStatedAs, 1),
      name = _getStatedAs2[0];

  if (!name) {
    name = typeof value === 'string' ? value : getLabel(value);
  }

  name = name ? (0, _name.parse)(name) : {
    literal: name
  };
  name._ordinal = getSeriesOrdinal(qualifiers);
  return name;
};

const parseNames = values => {
  return values.map(parseName).sort((a, b) => a._ordinal - b._ordinal);
};

const getPlace = value => {
  const country = value.claims.P17[0].value;
  const shortNames = country.claims.P1813.filter(({
    qualifiers: {
      P31
    }
  }) => !P31 || P31[0] !== 'Q28840786');
  return getLabel(value) + ', ' + (shortNames[0] || country.claims.P1448[0]).value;
};

const getTitle = value => {
  return value.claims.P1476 ? value.claims.P1476[0].value : getLabel(value);
};

const parseKeywords = values => {
  return values.map(({
    value
  }) => getLabel(value)).join(',');
};

const parseDateRange = dates => ({
  'date-parts': dates.map(date => (0, _date.parse)(date.value)).filter(date => date && date['date-parts']).map(date => date['date-parts'][0])
});

function parseProp(prop, value, entity) {
  switch (prop) {
    case 'type':
      return parseType(value);

    case 'author':
    case 'director':
    case 'container-author':
    case 'collection-editor':
    case 'composer':
    case 'editor':
    case 'illustrator':
    case 'original-author':
    case 'recipient':
    case 'reviewed-author':
    case 'translator':
      return parseNames(value);

    case 'issued':
    case 'original-date':
      return (0, _date.parse)(value);

    case 'event-date':
      return parseDateRange(value);

    case 'keyword':
      return parseKeywords(value);

    case 'container-title':
    case 'collection-title':
    case 'event':
    case 'medium':
    case 'publisher':
    case 'original-publisher':
      return getTitle(value);

    case 'event-place':
    case 'original-publisher-place':
    case 'publisher-place':
      return getPlace(value);

    case 'collection-number':
      return getSeriesOrdinal(value[0].qualifiers);

    case 'number-of-volumes':
      return value.length;

    default:
      return value;
  }
}

function parseType(type) {
  if (!_types.default[type]) {
    _core.logger.unmapped('[plugin-wikidata]', 'publication type', type);

    return 'book';
  }

  return _types.default[type];
}

function getLabel(entity) {
  if (!entity) {
    return undefined;
  }

  const lang = _config.default.langs.find(lang => entity.labels[lang]);

  return entity.labels[lang];
}