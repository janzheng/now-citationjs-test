"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _date = require("@citation-js/date");

var _types = _interopRequireDefault(require("./spec/types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const ISSN_REGEX = /^\d{4}-\d{4}$/;
const CONVERTERS = {
  ANY: {
    toTarget(...values) {
      return values.find(Boolean);
    },

    toSource(value) {
      return [value];
    }

  },
  PAGE: {
    keepAll: true,

    toTarget(start, end) {
      return [start, end].filter(Boolean).join('-');
    },

    toSource(pages) {
      return pages.replace(/[-–—]/g, '-');
    }

  },
  ISBN: {
    toTarget(id) {
      return ISSN_REGEX.test(id) ? [id] : [undefined, id];
    },

    toSource(...ids) {
      return ids.find(Boolean);
    }

  },
  DATE: {
    toTarget(date) {
      return date && (0, _date.parse)(date.split('/').slice(0, 3).filter(Boolean).join('/'));
    },

    toSource(date) {
      const parts = Array(4).fill('');
      date['date-parts'][0].forEach((part, index) => {
        parts[index] = part;
      });

      if (date.season) {
        parts[3] = date.season;
      }

      return parts.join('/');
    }

  },
  NAME: {
    toTarget(names) {
      return names && [].concat(names).map(name => {
        const parts = name.split(/, ?/);

        const _parts = _slicedToArray(parts, 3),
              family = _parts[0],
              given = _parts[1],
              suffix = _parts[2];

        switch (parts.length) {
          case 3:
            return {
              family,
              given,
              suffix
            };

          case 2:
            return {
              family,
              given
            };

          case 1:
            if (family.indexOf(' ') > -1) {
              return {
                family
              };
            }

          default:
            return {
              literal: name
            };
        }
      });
    },

    toSource(names) {
      return names.map(({
        family,
        given,
        suffix
      }) => [family, given, suffix].filter(Boolean).join(', '));
    }

  },
  KEYWORD: {
    toTarget(words) {
      return words.join(',');
    },

    toSource(words) {
      return words.split(',');
    }

  },
  ID: {
    toSource(id) {
      return id.slice(0, 20);
    }

  },
  TYPE: {
    toTarget(type) {
      return _types.default.RIS[type];
    },

    toSource(type) {
      return _types.default.CSL[type];
    }

  }
};
var _default = CONVERTERS;
exports.default = _default;