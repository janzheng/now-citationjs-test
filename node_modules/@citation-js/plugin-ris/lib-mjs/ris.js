function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import { util } from '@citation-js/core';
import config from './config';
import { SPECS } from './spec';
import CONVERTERS from './converters';
import DATA_TYPES from './dataTypes';
const LINE_MATCH = /^[A-Z][A-Z0-9] {2}-( |$)/;
const LINE_SPLIT = / {2}-(?: |$)/;
const TRANSLATORS = new Map();

function prepareTranslator(spec) {
  if (!TRANSLATORS.has(spec)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = spec[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        let mapping = _step.value;

        if (mapping.target in DATA_TYPES) {
          mapping.convert = CONVERTERS[DATA_TYPES[mapping.target]];
        }

        if (mapping.convert && mapping.convert.keepAll === true) {
          continue;
        }

        if (Array.isArray(mapping.source)) {
          if (mapping.convert) {
            const _mapping$convert = mapping.convert,
                  toSource = _mapping$convert.toSource,
                  toTarget = _mapping$convert.toTarget;
            mapping.convert = {
              toTarget(...args) {
                return toTarget(CONVERTERS.ANY.toTarget(...args));
              },

              toSource(...args) {
                return CONVERTERS.ANY.toSource(toSource(...args));
              }

            };
          } else {
            mapping.convert = CONVERTERS.ANY;
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    TRANSLATORS.set(spec, new util.Translator(spec));
  }

  return TRANSLATORS.get(spec);
}

export function parse(text) {
  const entries = [];
  let lastEntry;
  let lastTag;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = text.split('\n')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      let line = _step2.value;

      if (!LINE_MATCH.test(line)) {
        lastEntry[lastTag] += line;
      }

      const _line$split = line.split(LINE_SPLIT),
            _line$split2 = _slicedToArray(_line$split, 2),
            tag = _line$split2[0],
            value = _line$split2[1];

      switch (tag) {
        case 'ER':
          lastEntry = undefined;
          lastTag = undefined;
          break;

        case 'TY':
          lastEntry = {};
          entries.push(lastEntry);

        default:
          if (Array.isArray(lastEntry[tag])) {
            lastEntry[tag].push(value);
          } else {
            lastEntry[tag] = lastEntry[tag] ? [lastEntry[tag], value] : value;
          }

          lastTag = tag;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return entries;
}
export function parseOld(data) {
  return prepareTranslator(SPECS.old).convertToTarget(data);
}
export function parseNew(data) {
  return prepareTranslator(SPECS.new).convertToTarget(data);
}
export function parseMixed(data) {
  return prepareTranslator(SPECS.mixed).convertToTarget(data);
}
export function format(data, {
  type,
  format = type || 'text'
} = {}) {
  const entries = data.map(prepareTranslator(SPECS[config.outputSpec]).convertToSource);

  if (format === 'object') {
    return entries;
  }

  return entries.map(entry => {
    const tags = [];

    for (let tag in entry) {
      if (tag === 'TY') {
        continue;
      }

      tags.push(...[].concat(entry[tag]).map(value => `${tag}  - ${value.toString().replace(/(.{70})/g, '$1\n')}`));
    }

    tags.unshift(`TY  - ${entry.TY}`);
    tags.push('ER  - ');
    return tags.join('\n');
  }).join('\n');
}