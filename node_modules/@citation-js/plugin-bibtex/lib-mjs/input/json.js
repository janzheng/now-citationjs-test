function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import parseBibTeXProp from './prop';
import parseBibTeXType from './type';

const parseBibTeXJSON = function parseBibTeXJSON(data) {
  return [].concat(data).map(entry => {
    const newEntry = {};
    let toMerge = [];

    for (let prop in entry.properties) {
      const oldValue = entry.properties[prop];

      const _ref = parseBibTeXProp(prop, oldValue) || [],
            _ref2 = _slicedToArray(_ref, 2),
            cslField = _ref2[0],
            cslValue = _ref2[1];

      if (cslField) {
        if (/^[^:\s]+?:[^.\s]+(\.[^.\s]+)*$/.test(cslField)) {
          toMerge.push([cslField, cslValue]);
        } else {
          newEntry[cslField] = cslValue;
        }
      }
    }

    newEntry.type = parseBibTeXType(entry.type);
    newEntry.id = newEntry['citation-label'] = entry.label;

    if (/\d(\D+)$/.test(entry.label)) {
      newEntry['year-suffix'] = entry.label.match(/\d(\D+)$/)[1];
    }

    toMerge.forEach(([cslField, value]) => {
      const props = cslField.split(/:|\./g);
      let cursor = newEntry;

      while (props.length > 0) {
        const prop = props.shift();
        cursor = cursor[prop] || (cursor[prop] = !props.length ? value : isNaN(+props[0]) ? {} : []);
      }
    });
    return newEntry;
  });
};

export { parseBibTeXJSON as parse, parseBibTeXJSON as default };