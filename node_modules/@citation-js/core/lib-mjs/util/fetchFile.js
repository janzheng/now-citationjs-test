function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import request from 'sync-request';
import 'isomorphic-fetch';
import logger from '../logger';
import { version } from '../../package.json';
let userAgent = `Citation.js/${version} Node.js/${process.version}`;

function normaliseHeaders(headers) {
  const result = {};

  for (let header in headers) {
    result[header.toLowerCase()] = [].concat(headers[header]);
  }

  return result;
}

function parseOpts(opts = {}) {
  const reqOpts = {
    headers: {},
    method: 'GET'
  };

  if (userAgent) {
    reqOpts['user-agent'] = userAgent;
  }

  if (opts.headers) {
    reqOpts.headers = normaliseHeaders(opts.headers);
    reqOpts.allowRedirectHeaders = Object.keys(opts.headers);
  }

  if (opts.body) {
    reqOpts.method = 'POST';
    const isJson = typeof opts.body !== 'string';
    reqOpts.body = isJson ? JSON.stringify(opts.body) : opts.body;
    reqOpts.headers['content-type'] = reqOpts.headers['content-type'] || isJson ? 'application/json' : 'text/plain';
  }

  return reqOpts;
}

function sameType(request, response) {
  if (!request.accept || !response['content-type']) {
    return true;
  }

  const _response$contentTyp = response['content-type'][0].split(';')[0].split('/'),
        _response$contentTyp2 = _slicedToArray(_response$contentTyp, 2),
        a = _response$contentTyp2[0],
        b = _response$contentTyp2[1];

  return !!request.accept.reduce((array, header) => array.concat(header.split(/\s*,\s*/)), []).map(type => type.split(';')[0].split('/')).find(([c, d]) => (c === a || c === '*') && (d === b || d === '*'));
}

function checkResponse(response, opts) {
  const status = response.status || response.statusCode;
  const headers = response.headers._headers || response.headers;
  let error;

  if (status >= 400) {
    error = new Error(`Server responded with status code ${status}`);
  } else if (opts.checkContentType === true && !sameType(normaliseHeaders(opts.headers), normaliseHeaders(headers))) {
    error = new Error(`Server responded with content-type ${headers['content-type']}`);
  }

  if (error) {
    error.status = status;
    error.headers = headers;
    error.body = response.body;
    throw error;
  }

  return response;
}

export function fetchFile(url, opts) {
  const reqOpts = parseOpts(opts);
  logger.http('[core]', reqOpts.method, url, reqOpts);
  const response = checkResponse(request(reqOpts.method, url, reqOpts), reqOpts);
  return response.body.toString('utf8');
}
export function fetchFileAsync(_x, _x2) {
  return _fetchFileAsync.apply(this, arguments);
}

function _fetchFileAsync() {
  _fetchFileAsync = _asyncToGenerator(function* (url, opts) {
    const reqOpts = parseOpts(opts);
    logger.http('[core]', reqOpts.method, url, reqOpts);
    return fetch(url, reqOpts).then(response => checkResponse(response, reqOpts)).then(response => response.text());
  });
  return _fetchFileAsync.apply(this, arguments);
}

export function setUserAgent(newUserAgent) {
  userAgent = newUserAgent;
}
export default fetchFile;