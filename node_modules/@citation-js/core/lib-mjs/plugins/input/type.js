import logger from '../../logger';
import { dataTypeOf } from './dataType';
const types = {};
const dataTypes = {};
const unregExts = {};

const parseNativeTypes = (input, dataType) => {
  switch (dataType) {
    case 'Array':
      if (input.length === 0 || input.every(entry => type(entry) === '@csl/object')) {
        return '@csl/list+object';
      } else {
        return '@else/list+object';
      }

    case 'SimpleObject':
    case 'ComplexObject':
      return '@csl/object';

    default:
      return '@invalid';
  }
};

const matchType = (typeList = [], data) => {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = typeList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      const type = _step.value;

      if (types[type].predicate(data)) {
        return matchType(types[type].extensions, data) || type;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

export const type = input => {
  const dataType = dataTypeOf(input);

  if (dataType === 'Array' && input.length === 0) {
    return parseNativeTypes(input, dataType);
  }

  const match = matchType(dataTypes[dataType], input);
  return match || parseNativeTypes(input, dataType);
};
export const addTypeParser = (format, {
  dataType,
  predicate,
  extends: extend
}) => {
  let extensions = [];

  if (format in unregExts) {
    extensions = unregExts[format];
    delete unregExts[format];
    logger.debug('[core]', `Subclasses "${extensions}" finally registered to parent type "${format}"`);
  }

  const object = {
    predicate,
    extensions
  };
  types[format] = object;

  if (extend) {
    const parentTypeParser = types[extend];

    if (parentTypeParser) {
      parentTypeParser.extensions.push(format);
    } else {
      if (!unregExts[extend]) {
        unregExts[extend] = [];
      }

      unregExts[extend].push(format);
      logger.debug('[core]', `Subclass "${format}" is waiting on parent type "${extend}"`);
    }
  } else {
    const typeList = dataTypes[dataType] || (dataTypes[dataType] = []);
    typeList.push(format);
  }
};
export const hasTypeParser = type => types.hasOwnProperty(type);
export const removeTypeParser = type => {
  delete types[type];
  const typeLists = [...Object.keys(dataTypes).map(key => dataTypes[key]), ...Object.keys(types).map(type => types[type].extensions).filter(list => list.length > 0)];
  typeLists.forEach(typeList => {
    const index = typeList.indexOf(type);

    if (index > -1) {
      typeList.splice(index, 1);
    }
  });
};
export const listTypeParser = () => Object.keys(types);
export const treeTypeParser = () => {
  const attachNode = name => ({
    name,
    children: types[name].extensions.map(attachNode)
  });

  return {
    name: 'Type tree',
    children: Object.keys(dataTypes).map(name => ({
      name,
      children: dataTypes[name].map(attachNode)
    }))
  };
};
export const typeMatcher = /^(?:@(.+?))(?:\/(?:(.+?)\+)?(?:(.+)))?$/;