"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Translator = void 0;

function createConditionEval(condition) {
  return function conditionEval(input) {
    if (typeof condition === 'boolean') {
      return condition;
    }

    return Object.keys(condition).every(prop => {
      const value = condition[prop];

      if (value === true) {
        return prop in input;
      } else if (value === false) {
        return !(prop in input);
      } else if (typeof value === 'function') {
        return value(input[prop]);
      } else if (Array.isArray(value)) {
        return value.includes(input[prop]);
      } else {
        return input[prop] === value;
      }
    });
  };
}

function parsePropStatement(prop, toSource) {
  let inputProp;
  let outputProp;
  let convert;
  let condition;

  if (typeof prop === 'string') {
    inputProp = outputProp = prop;
  } else if (prop) {
    inputProp = toSource ? prop.target : prop.source;
    outputProp = toSource ? prop.source : prop.target;

    if (prop.convert) {
      convert = toSource ? prop.convert.toSource : prop.convert.toTarget;
    }

    if (prop.when) {
      condition = toSource ? prop.when.target : prop.when.source;

      if (condition != null) {
        condition = createConditionEval(condition);
      }
    }
  } else {
    return null;
  }

  inputProp = [].concat(inputProp).filter(Boolean);
  outputProp = [].concat(outputProp).filter(Boolean);
  return {
    inputProp,
    outputProp,
    convert,
    condition
  };
}

function createConverter(props, toSource) {
  toSource = toSource === Translator.CONVERT_TO_SOURCE;
  props = props.map(prop => parsePropStatement(prop, toSource)).filter(Boolean);
  return function converter(input) {
    let output = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        let _ref = _step.value;
        let inputProp = _ref.inputProp,
            outputProp = _ref.outputProp,
            convert = _ref.convert,
            condition = _ref.condition;

        if (outputProp.length === 0) {
          continue;
        } else if (condition && !condition(input)) {
          continue;
        } else if (inputProp.length !== 0 && inputProp.every(prop => !(prop in input))) {
          continue;
        }

        let outputData = inputProp.map(prop => input[prop]);

        if (convert) {
          let converted = convert.apply(input, outputData);
          outputData = outputProp.length === 1 ? [converted] : converted;
        }

        outputProp.forEach((prop, index) => {
          let value = outputData[index];

          if (value !== undefined) {
            output[prop] = value;
          }
        });
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return output;
  };
}

class Translator {
  constructor(props) {
    this.convertToSource = createConverter(props, Translator.CONVERT_TO_SOURCE);
    this.convertToTarget = createConverter(props, Translator.CONVERT_TO_TARGET);
  }

}

exports.Translator = Translator;
Translator.CONVERT_TO_SOURCE = Symbol('convert to source');
Translator.CONVERT_TO_TARGET = Symbol('convert to target');